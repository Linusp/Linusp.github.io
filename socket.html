---
title: 《TCP/IP Socket in C》阅读笔记
author: Linusp
layout: page
permalink: /notes/tcp-ip-socket-in-c.html
---
<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">说明</a></li>
<li><a href="#orgheadline2">套接字的创建和关闭</a></li>
<li><a href="#orgheadline3">设定地址</a></li>
<li><a href="#orgheadline4">TCP Socket</a></li>
<li><a href="#orgheadline5">信息构建</a></li>
<li><a href="#orgheadline6">UDP Socket</a></li>
<li><a href="#orgheadline7">Socket选项</a></li>
<li><a href="#orgheadline8">信号</a></li>
<li><a href="#orgheadline9">I/O模型</a></li>
<li><a href="#orgheadline10">多任务处理</a></li>
<li><a href="#orgheadline11">多路复用</a></li>
<li><a href="#orgheadline12">单播、多播和广播</a></li>
</ul>
</div>
</div>


<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">说明</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
Linux下的Socket编程，《TCP/IP Socket in C》一书阅读笔记。
</p>
</div>
</div>

<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">套接字的创建和关闭</h2>
<div class="outline-text-2" id="text-orgheadline2">
</div><div id="outline-container-orgheadline13" class="outline-3">
<h3 id="orgheadline13">创建套接字</h3>
<div class="outline-text-3" id="text-orgheadline13">
<p>
建立网络套接字需要调用函数socket()，该函数的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">socket</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">protocol_family</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">type</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">protocol</span>)
</pre>
</div>

<p>
使用这个函数需要包含两个头文件：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;sys/types.h&gt;</span>
<span class="linenr">2: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;sys/socket.h&gt;</span>
</pre>
</div>
<p>
后续的相关API使用，也要在包含这两个头文件的前提下进行。
</p>

<p>
第一个参数决定套接字的协议族，一般就使用 <b>PF_INET</b> ，这个协议族是IPv4的网络协议族，如果要使用IPv6的网络协议，就使用 <b>PF_INET6</b> 。在很多地方会说明这个参数一般使用 <b>AF_INET</b> ，实际上"AF"是"Address Family"的缩写而"PF"是"Protocol Family"的缩写，严格来说应该在这个函数中使用"PF_XXX"，而在设定地址的时候才用"AF_XXX"，但实际上使用"AF_XXX"也是可以的，在socket.h中有如下定义：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">#define</span> <span style="color: #eeeeec;">PF_INET</span> AF_INET
</pre>
</div>
<p>
执行man socket也可以发现其中内容使用的都是"AF_XXX"。
</p>

<p>
第二个参数确定套接字的类型，常用的两个值是 <b>SOCK_STREAM</b> 和 <b>SOCK_DGRAM</b> ，分别对应数流格式(TCP)和数据报格式(UDP)。
</p>

<p>
第三个参数用于自定端到端的特定协议，常用的协议有: <b>IPPROTO_TCP</b>, <b>IPPROTO_UDP</b>, <b>IPPROTO_SCTP</b>, <b>IPPROTO_TIPC</b> 等。协议和套接字类型是不能随意组合的，如 <b>SOCK_STREAM</b> 就不能和 <b>IPPROTO_UDP</b> 一起使用。当该参数置零时，会自动选择与套接字类型对应的 <b>默认协议</b> 。
</p>

<p>
如果套接字创建成功，该函数返回一个套接字描述符，否则返回-1，并将错误变量 <b>errno</b> 设置为对应的值(详情可man socket)。
</p>
</div>
</div>

<div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">关闭套接字</h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
关闭套接字需要调用函数close()，该函数的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">close</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">fd</span>)
</pre>
</div>
<p>
实际上这个函数并不是专用于关闭套接字的，而是用于关闭"文件"，对于Linux这样将一切设备视为文件的系统来说，这是一个通用的函数。
</p>

<p>
该函数只有一个参数，只要把相应的套接字描述符作为参数传入即可。套接字如果关闭成功，则返回0，否则返回-1，并会将错误变量 <b>errno</b> 设置为对应的值(详情可man close)。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline3" class="outline-2">
<h2 id="orgheadline3">设定地址</h2>
<div class="outline-text-2" id="text-orgheadline3">
</div><div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">相关结构</h3>
<div class="outline-text-3" id="text-orgheadline15">
<ul class="org-ul">
<li><p>
sockaddr
</p>

<p>
sockaddr是一个结构体，其结构为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span>{
<span class="linenr">2: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">short</span> <span style="color: #eeeeec;">sa_family</span>;   <span style="color: #888a85;">/* </span><span style="color: #888a85;">Address family  </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">sa_data</span>[14];           <span style="color: #888a85;">/* </span><span style="color: #888a85;">Family-specific address information</span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span>}
</pre>
</div>

<p>
第一个成员设定地址族(IPv4/IPv6等)，通常是设置为 <b>AF_INET</b> ；第二成员设定和地址族相关的地址信息，包括IP地址、端口等等信息，通常情况下并不会用到全部14个字节，这是socket API的设计者为了使socket API可以灵活应对各种不同的情况而做出的设计(具体是什么不同的情况呢？有待了解)。
</p></li>

<li><p>
sockaddr_in
</p>

<p>
sockaddr_in结构是对sockaddr结构在TCP/IP应用中的具体实现，其结构如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> {
<span class="linenr">2: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">short</span> <span style="color: #eeeeec;">sin_family</span>;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Internet protocol </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">short</span> <span style="color: #eeeeec;">sin_port</span>;    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Address port(16 bits) </span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">in_addr</span> <span style="color: #eeeeec;">sin_addr</span>;    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Internet address(32 bits) </span><span style="color: #888a85;">*/</span>
<span class="linenr">5: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">sin_zero</span>[8];           <span style="color: #888a85;">/* </span><span style="color: #888a85;">Not used </span><span style="color: #888a85;">*/</span>
<span class="linenr">6: </span>};
</pre>
</div>
<p>
其中结构体in_addr为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">in_addr</span>{
<span class="linenr">2: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">long</span> <span style="color: #eeeeec;">s_addr</span>;       <span style="color: #888a85;">/* </span><span style="color: #888a85;">Internet address (32 bits) </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>};
</pre>
</div>

<p>
sockaddr_in相对sockaddr，明确定义了成员sin_port和sin_addr用于设置端口和地址，实际上只用到了14个字节中的6个字节，剩下未用的8个字节(sin_zero)通常置零。
至于s_addr为何要封装到结构体in_addr中，据<a href="http://stackoverflow.com/questions/13979150/why-is-sin-addr-inside-the-structure-in-addr">stackoverflow上的回答</a> ，说是因为在不同的socket API中，结构in_addr中可能不只有一个成员，只是在POSIX中，该结构中只有一个成员s_addr而已。
</p>

<p>
<a href="http://kenby.iteye.com/blog/1149001">这篇文章</a> 说，sockaddr是给操作系统使用的，程序员应该操作sockaddr_in而不是sockaddr，在用sockaddr_in设置好地址信息后，再将sockaddr_in数据强制转换成sockaddr传递给系统调用函数。
</p></li>
</ul>
</div>
</div>

<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">具体操作</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
以下是一般的具体操作流程示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">addr</span>;        <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#27880;&#24847;&#65292;&#19981;&#35201;&#20351;&#29992;sockaddr </span><span style="color: #888a85;">*/</span>
<span class="linenr">2: </span>
<span class="linenr">3: </span>addr.sin_family = AF_INET;
<span class="linenr">4: </span>addr.sin_addr.s_addr = htonl(INADDR_ANY);<span style="color: #888a85;">/* </span><span style="color: #888a85;">&#26381;&#21153;&#31471;&#65292;&#23458;&#25143;&#31471;&#35843;&#29992;inet_addr </span><span style="color: #888a85;">*/</span>
<span class="linenr">5: </span>addr.sin_port = htons(PORT);             <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#35774;&#32622;&#31471;&#21475; </span><span style="color: #888a85;">*/</span>
<span class="linenr">6: </span>bzero(sin_zero, <span style="color: #729fcf;">sizeof</span>(sin_zero));       <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#23558;&#26410;&#29992;&#23383;&#33410;&#32622;&#38646; </span><span style="color: #888a85;">*/</span>
</pre>
</div>
<p>
这里的操作有几个要注意的地方：
</p>
<ul class="org-ul">
<li>设置地址和端口时，要将数据由本机字节序转换为网络字节序，常用的函数有 <b>htons</b>, <b>htonl</b> (相应的在接收网络数据时用 <b>ntohs</b>, <b>ntohl</b> 来将数据由网络字节序转换为本机字节序)</li>
<li>不能忘记将结构中未用的8字节数据置零，否则可能导致不可预知的错误</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-orgheadline4" class="outline-2">
<h2 id="orgheadline4">TCP Socket</h2>
<div class="outline-text-2" id="text-orgheadline4">
</div><div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">TCP C/S模型</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
TCP的C/S模型如下图所示：
<img src="../../../assets/img/tcp.png" alt="tcp.png" />
</p>
</div>
</div>

<div id="outline-container-orgheadline18" class="outline-3">
<h3 id="orgheadline18">TCP客户端</h3>
<div class="outline-text-3" id="text-orgheadline18">
<p>
创建TCP客户端的基本步骤为：
</p>
<ol class="org-ol">
<li><p>
调用socket()创建套接字以建立和服务端的连接
</p>

<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>;
<span class="linenr">2: </span>sockfd = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
</pre>
</div></li>
<li><p>
调用connect()连接服务端
</p>

<p>
connect()函数的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">connect</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">const</span> <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">addr</span>, <span style="color: #8ae234;">socklen_t</span> <span style="color: #eeeeec;">addrlen</span>);
</pre>
</div>
<p>
第一个参数是用socket()函数返回的套接字描述符，和创建的套接字绑定；第二个参数是一个sockaddr结构类型的指针，用来设置要连接的服务端的地址信息，实际情况中一般是用一个sockaddr_in结构类型的指针作为实参；第三个参数是地址结构的长度，即 <code>sizeof(struct sockaddr_in)</code> 。
</p>

<p>
若绑定成功，该函数返回0，否则返回-1，并设置相应的错误号。
</p></li>
<li><p>
调用send()和recv()和服务端通信
</p>

<p>
send()函数和recv()函数的原型很相似：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">ssize_t</span> <span style="color: #edd400;">send</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">buf</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">len</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">flags</span>);
<span class="linenr">2: </span><span style="color: #8ae234;">ssize_t</span> <span style="color: #edd400;">recv</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">buf</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">len</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">flags</span>);
</pre>
</div>
<p>
send()和recv()默认都是阻塞的，它们的最后一个参数flags可以用来改变函数的默认行为，默认情况下置零。
</p>

<p>
send()如果发送成功，则返回发送的数据长度(字节)；否则返回-1，并将错误变量 <b>errno</b> 设置为相应的值。
</p>

<p>
recv()返回接收的数据长度(字节)；如果出错则返回-1并将错误变量 <b>errno</b> 设置对应的值；如果连接已经关闭，则返回0。
</p></li>
<li><p>
调用close()关闭连接
</p>

<p>
在最后，不需要再和服务端通信了，就调用close()函数来关闭连接。
</p></li>
</ol>
</div>
</div>

<div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">TCP服务端</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
创建TCP服务端的基本步骤为：
</p>
<ol class="org-ol">
<li><p>
调用socket()创建套接字
</p>

<p>
这一步和客户端一样，不过建立的和这个套接字的用途和客户端建立的套接字不太一样。
</p></li>
<li><p>
调用bind()将套接字绑定一个端口
</p>

<p>
函数bind()的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">bind</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">const</span> <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">addr</span>, <span style="color: #8ae234;">socklen_t</span> <span style="color: #eeeeec;">addrlen</span>);
</pre>
</div>
<p>
第一个参数使用第1步建立的套接字，第二个参数在设置时应将地址设置为 <b>INADDR_ANY</b> 、将端口设置为服务端的周知端口，第三个参数则是地址结构的长度。
</p>

<p>
绑定成功则返回0；否则返回-1，并将错误变量 <b>errno</b> 设置为对应的值。
</p></li>
<li><p>
调用listen()监听连接请求
</p>

<p>
listen()函数的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">listen</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">quene_limit</span>);
</pre>
</div>
<p>
调用该函数将使套接字监听TCP连接请求，当发生请求时，就将请求放入队列等待后面调用accept()来进行处理。第二个参数就是请求队列的长度上限。
</p>

<p>
正常情况下，该函数返回0；若出错，则返回-1，并将错误变量 <b>errno</b> 设置为对应的值。
</p></li>
<li>重复做以下事情
<ul class="org-ul">
<li><p>
调用accept()为每个客户端连接请求建立一个套接字
</p>

<p>
在第1步建立的套接字并不进行实际的数据发送、接收操作，它更像一个套接字工厂，对每个新的TCP连接，accept()会创建一个新的套接字，和客户端的套接字形成一个套接字对从而建立一个通信的通道。
</p>

<p>
accept()的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">accept</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">addr</span>, <span style="color: #8ae234;">socklen_t</span> *<span style="color: #eeeeec;">addrlen</span>);
</pre>
</div>
<p>
其中第一个参数是之前说的"套接字工厂"，第二个参数和第三个参数用来保存客户端的地址信息以及地址信息长度。
</p>

<p>
正常情况下该函数返回一个可用的套接字描述符；否则返回-1并将错误变量 <b>errno</b> 设置为对应的值。
</p></li>
<li>调用send()和recv()和客户端进行通信</li>
<li>调用close()关闭和客户端的连接</li>
</ul></li>
</ol>
</div>
</div>
</div>
<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">信息构建</h2>
<div class="outline-text-2" id="text-orgheadline5">
</div><div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">字节序</h3>
<div class="outline-text-3" id="text-orgheadline20">
<p>
通信的两端的本机字节序可能不一致，如果不加处理地将信息进行发送，接收方可能得到的是错误的数据。解决办法是在进行send()的时候将数据由本机字节序转换为网络字节序，而另一端在接收时将数据由网络字节序转换为本机字节序。
</p>

<p>
这些操作可以使用这些函数：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">uint32_t</span> <span style="color: #edd400;">htonl</span>(<span style="color: #8ae234;">uint32_t</span> <span style="color: #eeeeec;">hostlong</span>);
<span class="linenr">2: </span><span style="color: #8ae234;">uint16_t</span> <span style="color: #edd400;">htonl</span>(<span style="color: #8ae234;">uint16_t</span> <span style="color: #eeeeec;">hostshort</span>);
<span class="linenr">3: </span><span style="color: #8ae234;">uint32_t</span> <span style="color: #edd400;">ntohl</span>(<span style="color: #8ae234;">uint32_t</span> <span style="color: #eeeeec;">netlong</span>);
<span class="linenr">4: </span><span style="color: #8ae234;">uint16_t</span> <span style="color: #edd400;">ntohs</span>(<span style="color: #8ae234;">uint16_t</span> <span style="color: #eeeeec;">netshort</span>);
</pre>
</div>
<p>
如果数据本身的最小单元是一个字节，则无须进行字节序转换处理，但如果最小单元超过一个字节，如要收发的数据中包含int类型、long类型的数据，则应当进行字节序转换处理。
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">字节对齐和填充</h3>
<div class="outline-text-3" id="text-orgheadline21">
<p>
如果定义一个结构体来容纳数据，那么要注意结构体内字节对齐和填充的现象。如
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">Msg</span>{
<span class="linenr">2: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">a</span>;                      <span style="color: #888a85;">/* </span><span style="color: #888a85;">4 Bytes </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">b</span>;                     <span style="color: #888a85;">/* </span><span style="color: #888a85;">1 Byte </span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">c</span>;                      <span style="color: #888a85;">/* </span><span style="color: #888a85;">4 Bytes </span><span style="color: #888a85;">*/</span>
<span class="linenr">5: </span>};
</pre>
</div>
<p>
如果用该结构体容纳数据，在进行收发时，将长度计算为9字节是错误的，一个该结构类型的数据所占的实际存储空间是12字节，原因是每个类型的数据在存储时都会对齐在能整除其数据类型长度的地址处，所以成员b后会有一个3字节的空洞。
</p>

<p>
正确的结构体定义应该是这样的：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">Msg</span>{
<span class="linenr">2: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">a</span>;
<span class="linenr">3: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">c</span>;
<span class="linenr">4: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">b</span>;
<span class="linenr">5: </span>};
</pre>
</div>
<p>
这样的结构体的长度就和预期的一致。
</p>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-3">
<h3 id="orgheadline22">信息格式化</h3>
<div class="outline-text-3" id="text-orgheadline22">
<p>
在实际场景中，收发的数据会有复杂的格式需求，所以需要编写专门的编码和解析函数来对发送数据进行格式化、对接收数据进行解析。
</p>

<p>
格式化的简单方法有使用结构体、使用约定的分割符(终止符)等。
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline6" class="outline-2">
<h2 id="orgheadline6">UDP Socket</h2>
<div class="outline-text-2" id="text-orgheadline6">
</div><div id="outline-container-orgheadline23" class="outline-3">
<h3 id="orgheadline23">UDP的C/S模型</h3>
<div class="outline-text-3" id="text-orgheadline23">
<p>
UDP的C/S模型如下图所示：
<img src="../../../assets/img/udp.png" alt="udp.png" />
</p>

<p>
可以发现UDP的模型比TCP的模型要简单。
</p>
</div>
</div>
<div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">UDP与TCP的区别</h3>
<div class="outline-text-3" id="text-orgheadline24">
<p>
UDP是无连接的，在进行通信前，UDP客户端程序不需要先进行connect(服务端也不需要进行listen和accept)。
</p>

<p>
TCP连接可以类比于打电话，而UDP连接可以类比于发邮件。
</p>

<p>
UDP socket只要一被建立，就可以用于和许多不同的地址之间进行通信。UDP通信不使用send()和recv()函数，而是使用sendto()和recvfrom()函数：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">ssize_t</span> <span style="color: #edd400;">sendto</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">buf</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">len</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">flags</span>,
<span class="linenr">2: </span>               <span style="color: #729fcf;">const</span> <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">dest_addr</span>, <span style="color: #8ae234;">socklen_t</span> <span style="color: #eeeeec;">addrlen</span>);
<span class="linenr">3: </span><span style="color: #8ae234;">ssize_t</span> <span style="color: #edd400;">recvfrom</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">buf</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">len</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">flags</span>,
<span class="linenr">4: </span>                 <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">src_addr</span>, <span style="color: #8ae234;">socklen_t</span> *<span style="color: #eeeeec;">addrlen</span>);
</pre>
</div>
<p>
sendto()和recvfrom()的前四个参数和send()、recv()是一样的。sendto()的后两个参数 <b>指定</b> 了消息目的地的地址信息；recvfrom()的后两个参数则用于 <b>保存</b> 消息来源地的地址信息。
</p>

<p>
特别要注意的是recvfrom()的最后一个参数，该参数既是输入也是输出。作为输入，它指定了指针src_addr所指向的结构的大小；作为输出，它会记录消息来源的地址结构长度。如果忘记将指针addrlen对应的变量的值初始化，则会导致错误。如：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>;
<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">their_addr</span>;
<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">their_addr_len</span>;
<span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">msg</span>[256];
<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">msg_len</span> = <span style="color: #729fcf;">sizeof</span>(msg);

bzero(&amp;their_addr, <span style="color: #729fcf;">sizeof</span>(their_addr));
their_addr.sin_family = AF_INET;
their_addr.sin_addr.s_addr = inet_addr(<span style="color: #ad7fa8;">"127.0.0.1"</span>);
their_addr.sin_port = htons(8888);

sockfd = socket(AF_INET, SOCK_DGRAM, 0);
<span style="color: #729fcf;">while</span> (1) {
    recvfrom(sockfd, msg, msg_len, 0,
             (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)&amp;their_addr, &amp;their_addr_len);
}
</pre>
</div>
<p>
是错误的——当然，这里的错误主要是指在recvfrom()前没有初始化their_addr_len这个变量，实际上上面这段代码既没有进行错误检查，功能也是不完整的。正确的应该是这样的：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr"> 1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>;
<span class="linenr"> 2: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">their_addr</span>;
<span class="linenr"> 3: </span><span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">msg</span>[256];
<span class="linenr"> 4: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">msg_len</span> = <span style="color: #729fcf;">sizeof</span>(msg);
<span class="linenr"> 5: </span>
<span class="linenr"> 6: </span>bzero(&amp;their_addr, <span style="color: #729fcf;">sizeof</span>(their_addr));
<span class="linenr"> 7: </span>their_addr.sin_family = AF_INET;
<span class="linenr"> 8: </span>their_addr.sin_addr.s_addr = inet_addr(<span style="color: #ad7fa8;">"127.0.0.1"</span>);
<span class="linenr"> 9: </span>their_addr.sin_port = htons(8888);
<span class="linenr">10: </span>
<span class="linenr">11: </span>sockfd = socket(AF_INET, SOCK_DGRAM, 0);
<span class="linenr">12: </span><span style="color: #729fcf;">while</span> (1) {
<span class="linenr">13: </span>    their_addr_len = <span style="color: #729fcf;">sizeof</span>(their_addr);
<span class="linenr">14: </span>    recvfrom(sockfd, msg, msg_len, 0,
<span class="linenr">15: </span>             (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)&amp;their_addr, &amp;their_addr_len);
<span class="linenr">16: </span>}
</pre>
</div>
<p>
当然，UDP和TCP最大的区别是：UDP不保证发送的信息一定能到达目的地，它只是负责发送出去，然后就不管了。
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline7" class="outline-2">
<h2 id="orgheadline7">Socket选项</h2>
<div class="outline-text-2" id="text-orgheadline7">
<p>
socket选项用于改变socket的默认行为，如改变socket的接收缓冲区的默认大小。
</p>

<p>
获取socket选项的值和设置选项的值可以使用下面两个函数：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">getsockopt</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">level</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">opt_name</span>,
<span class="linenr">2: </span>               <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">opt_val</span>, <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> *<span style="color: #eeeeec;">opt_len</span>);
<span class="linenr">3: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">setsockopt</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">level</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">opt_name</span>,
<span class="linenr">4: </span>               <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">void</span> *<span style="color: #eeeeec;">opt_val</span>, <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">opt_len</span>);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-2">
<h2 id="orgheadline8">信号</h2>
<div class="outline-text-2" id="text-orgheadline8">
<p>
信号(signals)是用来通知程序“发生了某些事件(events)”的一种机制。一个信号被传递到正在运行的程序时，会被以下方式中的一种进行处理：
</p>
<ol class="org-ol">
<li>信号被忽略</li>
<li>程序被操作系统终止</li>
<li>一个特定的处理例程启动，用于针对信号做出具体的处理</li>
<li>信号被阻塞</li>
</ol>

<p>
socket编程中常用的一些信号有：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">信号</th>
<th scope="col" class="org-left">触发事件</th>
<th scope="col" class="org-left">缺省行为</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">SIGALRM</td>
<td class="org-left">时钟计时器到期</td>
<td class="org-left">终止</td>
</tr>

<tr>
<td class="org-left">SIGCHLD</td>
<td class="org-left">子进程结束</td>
<td class="org-left">忽略</td>
</tr>

<tr>
<td class="org-left">SIGINT</td>
<td class="org-left">终止符输入</td>
<td class="org-left">终止</td>
</tr>

<tr>
<td class="org-left">SIGIO</td>
<td class="org-left">套接字准备好进行读写</td>
<td class="org-left">忽略</td>
</tr>

<tr>
<td class="org-left">SIGPIPE</td>
<td class="org-left">对已关闭的套接字进行写操作</td>
<td class="org-left">终止</td>
</tr>
</tbody>
</table>

<p>
可以使用sigaction()来改变对于某个信号的缺省处理方式：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">sigaction</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">signum</span>, <span style="color: #729fcf;">const</span> <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sigaction</span> *<span style="color: #eeeeec;">act</span>,
<span class="linenr">2: </span>              <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sigaction</span> *<span style="color: #eeeeec;">oldact</span>);
</pre>
</div>
<p>
第一个参数用来指示要改变缺省处理方式的信号；第二个参数则定义了对该信号的新的处理方式；第三个参数若不为空，则对该信号的原处理方式的信息会被记录于该参数中。
</p>

<p>
该函数正常时返回0，出错则返回-1。
</p>

<p>
结构体sigaction的具体结构如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sigaction</span> {
<span class="linenr">2: </span>    <span style="color: #8ae234;">void</span> (*<span style="color: #edd400;">sa_hanlder</span>)(<span style="color: #8ae234;">int</span>);    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Signal hanlder </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>    <span style="color: #8ae234;">sigset_t</span> <span style="color: #eeeeec;">sa_mask</span>; <span style="color: #888a85;">/* </span><span style="color: #888a85;">Signals to be blocked during handler execution </span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sa_flags</span>;     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Flags to modify default behavior </span><span style="color: #888a85;">*/</span>
<span class="linenr">5: </span>}
</pre>
</div>
<p>
其中第一个结构成员 <b>sa_hanlder</b> 用来指定信号处理方法，除了用户自定义的信号处理函数，它的值还可能是两个特殊的常量 <b>SIG_IGN</b> 和 <b>SIG_DFL</b> ，前者将使信号被忽略，后者将使信号的默认处理行为被使用。
</p>

<p>
第二个结构成员 <b>sa_mask</b> 用来设置额外的信号屏蔽码，设置了 <b>sa_mask</b> 后，除了原先默认的被屏蔽信号外，消息处理方法中还会屏蔽额外设置的信号，待处理完后，被屏蔽的信号又变回默认的。 <b>sa_mask</b> 本质是一个信号集，而信号集的操作则通过以下方法：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">sigemptyset</span>(<span style="color: #8ae234;">sigset_t</span> *<span style="color: #eeeeec;">set</span>);
<span class="linenr">2: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">sigfillset</span>(<span style="color: #8ae234;">sigset_t</span> *<span style="color: #eeeeec;">set</span>);
<span class="linenr">3: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">sigaddset</span>(<span style="color: #8ae234;">sigset_t</span> *<span style="color: #eeeeec;">set</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">signum</span>);
<span class="linenr">4: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">sigdelset</span>(<span style="color: #8ae234;">sigset_t</span> *<span style="color: #eeeeec;">set</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">signum</span>);
</pre>
</div>
<p>
第一个函数将信号集初始化为空集；第二个函数将集合初始化为所有信号的集合；第三个和第四个则分别用于将特定的信号加入信号集和从信号集中移除特定的信号。这四个函数的正常返回值都是0，如果出错则返回-1。
</p>

<p>
在程序中处理信号一般是这样的：
</p>
<ol class="org-ol">
<li>定义信号处理(struct sigaction)变量</li>
<li>初始化信号处理变量，实现信号处理方法</li>
<li>将信号处理方法和信号绑定(使用sigaction()函数)</li>
</ol>
</div>

<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">超时检测</h3>
<div class="outline-text-3" id="text-orgheadline25">
<p>
使用函数alarm()可以实现对连接超时的设定和处理，比如客户端连接服务器时，如果一段时间内没有连接上就认为超时。该函数原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #edd400;">alarm</span>(<span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">secs</span>);
</pre>
</div>
<p>
alarm()会启动一个计时器，当计时终止时，就会触发一个 <b>SIGALRM</b> 信号。在一个可能阻塞的函数调用前启动计时器，如果当计时终止时函数仍然阻塞，则函数会被终止并返回-1，同时错误变量 <b>errno</b> 被设置为 <b>EINTR</b> 。
</p>

<p>
根据这些特性，就可以在socket操作中进行超时检测了。以下是一个示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">  1: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>      <span style="color: #888a85;">/* </span><span style="color: #888a85;">for printf() and fprintf() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  2: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;sys/socket.h&gt;</span> <span style="color: #888a85;">/* </span><span style="color: #888a85;">for socket(), connect(), sendto(), and recvfrom() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  3: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;arpa/inet.h&gt;</span>  <span style="color: #888a85;">/* </span><span style="color: #888a85;">for sockaddr_in and inet_addr() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  4: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdlib.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for atoi() and exit() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  5: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for memset() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  6: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;unistd.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for close() and alarm() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  7: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;errno.h&gt;</span>      <span style="color: #888a85;">/* </span><span style="color: #888a85;">for errno and EINTR </span><span style="color: #888a85;">*/</span>
<span class="linenr">  8: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;signal.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for sigaction() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  9: </span>
<span class="linenr"> 10: </span><span style="color: #729fcf;">#define</span> <span style="color: #eeeeec;">ECHOMAX</span>         255     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Longest string to echo </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 11: </span><span style="color: #729fcf;">#define</span> <span style="color: #eeeeec;">TIMEOUT_SECS</span>    2       <span style="color: #888a85;">/* </span><span style="color: #888a85;">Seconds between retransmits </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 12: </span><span style="color: #729fcf;">#define</span> <span style="color: #eeeeec;">MAXTRIES</span>        5       <span style="color: #888a85;">/* </span><span style="color: #888a85;">Tries before giving up </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 13: </span>
<span class="linenr"> 14: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">tries</span>=0;   <span style="color: #888a85;">/* </span><span style="color: #888a85;">Count of times sent - GLOBAL for signal-handler access </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 15: </span>
<span class="linenr"> 16: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">DieWithError</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">errorMessage</span>);   <span style="color: #888a85;">/* </span><span style="color: #888a85;">Error handling function </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 17: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">CatchAlarm</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">ignored</span>);            <span style="color: #888a85;">/* </span><span style="color: #888a85;">Handler for SIGALRM </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 18: </span>
<span class="linenr"> 19: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
<span class="linenr"> 20: </span>{
<span class="linenr"> 21: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sock</span>;                        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Socket descriptor </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 22: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">echoServAddr</span>; <span style="color: #888a85;">/* </span><span style="color: #888a85;">Echo server address </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 23: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">fromAddr</span>;     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Source address of echo </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 24: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">short</span> <span style="color: #eeeeec;">echoServPort</span>;     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Echo server port </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 25: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">fromSize</span>;           <span style="color: #888a85;">/* </span><span style="color: #888a85;">In-out of address size for recvfrom() </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 26: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sigaction</span> <span style="color: #eeeeec;">myAction</span>;       <span style="color: #888a85;">/* </span><span style="color: #888a85;">For setting signal handler </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 27: </span>    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">servIP</span>;                    <span style="color: #888a85;">/* </span><span style="color: #888a85;">IP address of server </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 28: </span>    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">echoString</span>;                <span style="color: #888a85;">/* </span><span style="color: #888a85;">String to send to echo server </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 29: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">echoBuffer</span>[ECHOMAX+1];      <span style="color: #888a85;">/* </span><span style="color: #888a85;">Buffer for echo string </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 30: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">echoStringLen</span>;               <span style="color: #888a85;">/* </span><span style="color: #888a85;">Length of string to echo </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 31: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">respStringLen</span>;               <span style="color: #888a85;">/* </span><span style="color: #888a85;">Size of received datagram </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 32: </span>
<span class="linenr"> 33: </span>    <span style="color: #729fcf;">if</span> ((argc &lt; 3) || (argc &gt; 4))    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Test for correct number of arguments </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 34: </span>    {
<span class="linenr"> 35: </span>        fprintf(stderr,<span style="color: #ad7fa8;">"Usage: %s &lt;Server IP&gt; &lt;Echo Word&gt; [&lt;Echo Port&gt;]\n"</span>, argv[0]);
<span class="linenr"> 36: </span>        exit(1);
<span class="linenr"> 37: </span>    }
<span class="linenr"> 38: </span>
<span class="linenr"> 39: </span>    servIP = argv[1];           <span style="color: #888a85;">/* </span><span style="color: #888a85;">First arg:  server IP address (dotted quad) </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 40: </span>    echoString = argv[2];       <span style="color: #888a85;">/* </span><span style="color: #888a85;">Second arg: string to echo </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 41: </span>
<span class="linenr"> 42: </span>    <span style="color: #729fcf;">if</span> ((echoStringLen = strlen(echoString)) &gt; ECHOMAX)
<span class="linenr"> 43: </span>        DieWithError(<span style="color: #ad7fa8;">"Echo word too long"</span>);
<span class="linenr"> 44: </span>
<span class="linenr"> 45: </span>    <span style="color: #729fcf;">if</span> (argc == 4)
<span class="linenr"> 46: </span>        echoServPort = atoi(argv[3]);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Use given port, if any </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 47: </span>    <span style="color: #729fcf;">else</span>
<span class="linenr"> 48: </span>        echoServPort = 7;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">7 is well-known port for echo service </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 49: </span>
<span class="linenr"> 50: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Create a best-effort datagram socket using UDP </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 51: </span>    <span style="color: #729fcf;">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)
<span class="linenr"> 52: </span>        DieWithError(<span style="color: #ad7fa8;">"socket() failed"</span>);
<span class="linenr"> 53: </span>
<span class="linenr"> 54: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Set signal handler for alarm signal </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 55: </span>    myAction.sa_handler = CatchAlarm;
<span class="linenr"> 56: </span>    <span style="color: #729fcf;">if</span> (sigfillset(&amp;myAction.sa_mask) &lt; 0) <span style="color: #888a85;">/* </span><span style="color: #888a85;">block everything in handler </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 57: </span>        DieWithError(<span style="color: #ad7fa8;">"sigfillset() failed"</span>);
<span class="linenr"> 58: </span>    myAction.sa_flags = 0;
<span class="linenr"> 59: </span>
<span class="linenr"> 60: </span>    <span style="color: #729fcf;">if</span> (sigaction(SIGALRM, &amp;myAction, 0) &lt; 0)
<span class="linenr"> 61: </span>        DieWithError(<span style="color: #ad7fa8;">"sigaction() failed for SIGALRM"</span>);
<span class="linenr"> 62: </span>
<span class="linenr"> 63: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Construct the server address structure </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 64: </span>    memset(&amp;echoServAddr, 0, <span style="color: #729fcf;">sizeof</span>(echoServAddr));    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Zero out structure </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 65: </span>    echoServAddr.sin_family = AF_INET;
<span class="linenr"> 66: </span>    echoServAddr.sin_addr.s_addr = inet_addr(servIP);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Server IP address </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 67: </span>    echoServAddr.sin_port = htons(echoServPort);       <span style="color: #888a85;">/* </span><span style="color: #888a85;">Server port </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 68: </span>
<span class="linenr"> 69: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Send the string to the server </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 70: </span>    <span style="color: #729fcf;">if</span> (sendto(sock, echoString, echoStringLen, 0, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)
<span class="linenr"> 71: </span>               &amp;echoServAddr, <span style="color: #729fcf;">sizeof</span>(echoServAddr)) != echoStringLen)
<span class="linenr"> 72: </span>        DieWithError(<span style="color: #ad7fa8;">"sendto() sent a different number of bytes than expected"</span>);
<span class="linenr"> 73: </span>
<span class="linenr"> 74: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Get a response </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 75: </span>
<span class="linenr"> 76: </span>    fromSize = <span style="color: #729fcf;">sizeof</span>(fromAddr);
<span class="linenr"> 77: </span>    alarm(TIMEOUT_SECS);        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Set the timeout </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 78: </span>    <span style="color: #729fcf;">while</span> ((respStringLen = recvfrom(sock, echoBuffer, ECHOMAX, 0,
<span class="linenr"> 79: </span>                                     (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *) &amp;fromAddr, &amp;fromSize)) &lt; 0)
<span class="linenr"> 80: </span>        <span style="color: #729fcf;">if</span> (errno == EINTR)     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Alarm went off  </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 81: </span>        {
<span class="linenr"> 82: </span>            <span style="color: #729fcf;">if</span> (tries &lt; MAXTRIES)      <span style="color: #888a85;">/* </span><span style="color: #888a85;">incremented by signal handler </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 83: </span>            {
<span class="linenr"> 84: </span>                printf(<span style="color: #ad7fa8;">"timed out, %d more tries...\n"</span>, MAXTRIES-tries);
<span class="linenr"> 85: </span>                <span style="color: #729fcf;">if</span> (sendto(sock, echoString, echoStringLen, 0, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)
<span class="linenr"> 86: </span>                           &amp;echoServAddr, <span style="color: #729fcf;">sizeof</span>(echoServAddr)) != echoStringLen)
<span class="linenr"> 87: </span>                    DieWithError(<span style="color: #ad7fa8;">"sendto() failed"</span>);
<span class="linenr"> 88: </span>                alarm(TIMEOUT_SECS);
<span class="linenr"> 89: </span>            }
<span class="linenr"> 90: </span>            <span style="color: #729fcf;">else</span>
<span class="linenr"> 91: </span>                DieWithError(<span style="color: #ad7fa8;">"No Response"</span>);
<span class="linenr"> 92: </span>        }
<span class="linenr"> 93: </span>        <span style="color: #729fcf;">else</span>
<span class="linenr"> 94: </span>            DieWithError(<span style="color: #ad7fa8;">"recvfrom() failed"</span>);
<span class="linenr"> 95: </span>
<span class="linenr"> 96: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">recvfrom() got something --  cancel the timeout </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 97: </span>    alarm(0);
<span class="linenr"> 98: </span>
<span class="linenr"> 99: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">null-terminate the received data </span><span style="color: #888a85;">*/</span>
<span class="linenr">100: </span>    echoBuffer[respStringLen] = <span style="color: #ad7fa8;">'\0'</span>;
<span class="linenr">101: </span>    printf(<span style="color: #ad7fa8;">"Received: %s\n"</span>, echoBuffer);    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Print the received data </span><span style="color: #888a85;">*/</span>
<span class="linenr">102: </span>
<span class="linenr">103: </span>    close(sock);
<span class="linenr">104: </span>    exit(0);
<span class="linenr">105: </span>}
<span class="linenr">106: </span>
<span class="linenr">107: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">CatchAlarm</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">ignored</span>)     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Handler for SIGALRM </span><span style="color: #888a85;">*/</span>
<span class="linenr">108: </span>{
<span class="linenr">109: </span>    tries += 1;
<span class="linenr">110: </span>}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline9" class="outline-2">
<h2 id="orgheadline9">I/O模型</h2>
<div class="outline-text-2" id="text-orgheadline9">
</div><div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">阻塞与非阻塞I/O</h3>
<div class="outline-text-3" id="text-orgheadline26">
<p>
在进行读操作时，如果缓冲区中没有数据，相应的函数就不会返回，线程会一直等待直到缓冲区中有数据；在进行写操作时，如果缓冲区已满，相应的函数也不会返回，一直等待到其他进程从缓冲区中读了一定的数据使得缓冲区非空。这种I/O模式就是阻塞式I/O。socket中的read()/readfrom()、send()/sendto()、accept()和connect()默认情况下都是阻塞式的。阻塞模式下，accept()在没有客户端发出连接时会一直等待，connect()会在建立连接成功前一直等到(直到超时)。
</p>

<p>
在阻塞模式下，在I/O操作完成前，函数会 <b>一直等待</b> 而不会 <b>立即返回</b> ，且该函数所在的线程会被阻塞。
</p>

<p>
非阻塞模式时，如果当前的I/O操作暂时不能完成，非得让线程等待时，线程就不等待，函数直接返回一个错误(EAGAIN/EWOULDBLOCK,connect()返回EINPROGRESS)。这种情况下，需要应用程序靠轮询来检查操作是否可用，这对CPU时间是极大的浪费。
</p>

<p>
socket的各个函数默认都是阻塞式的，使用fcntl()函数可以改变默认行为，使它们变成非阻塞式的。
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">fcntl</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">socket</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">command</span>, <span style="color: #8ae234;">long</span> <span style="color: #eeeeec;">arg</span>);
</pre>
</div>
<p>
这个函数可以获取/设置套接字的flags。第一个参数就是相应的套接字描述符，第二个参数为 <b>F_GETFL</b> 或 <b>F_SETFL</b> ，前者用来获取flags，或者用来设置flags。而非阻塞的flag值为 <b>O_NONBLOCK</b> 。
</p>

<p>
可以这样将socket设置为非阻塞：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span>fcntl(sockfd, F_SETFL, fcntl(sockfd, F_GETFL) | O_NONBLOCK);
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">同步与异步I/O</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
同步I/O模式下，操作必须是按部就班的，做完一件事情才能做下一件事情。从这个意义上来说，阻塞与非阻塞都可以算是同步的，或者说，只有在同步I/O模式下，阻塞与非阻塞的区分才有意义。
</p>

<p>
对于异步I/O来说，应用程序不需要在做完一件事情前一直等待或者轮询，而是在一件事情没做好时去做别的事情，当之前的某个操作完成时， <b>由内核来通知应用程序</b> 。在异步I/O模式下，应用程序是不会阻塞在某个I/O操作中的，因此在异步I/O模式下讨论阻塞与非阻塞也是没有意义的。
</p>

<p>
异步I/O通过传递信号 <b>SIGIO</b> 来工作。
</p>

<p>
在socket编程中使用异步模型，首先要定义对信号 <b>SIGIO</b> 的处理方法并和信号 <b>SIGIO</b> 绑定；其次要将套接字设置为异步和非阻塞模式(使用fcntl())；最后还要将当前的进程设置为套接字的“拥有者”(使用fcntl())。
</p>

<p>
下面是一个使用异步I/O的UDP Server示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">  1: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>      <span style="color: #888a85;">/* </span><span style="color: #888a85;">for printf() and fprintf() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  2: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;sys/socket.h&gt;</span> <span style="color: #888a85;">/* </span><span style="color: #888a85;">for socket(), bind, and connect() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  3: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;arpa/inet.h&gt;</span>  <span style="color: #888a85;">/* </span><span style="color: #888a85;">for sockaddr_in and inet_ntoa() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  4: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdlib.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for atoi() and exit() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  5: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for memset() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  6: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;unistd.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for close() and getpid() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  7: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;fcntl.h&gt;</span>      <span style="color: #888a85;">/* </span><span style="color: #888a85;">for fcntl() </span><span style="color: #888a85;">*/</span>
<span class="linenr">  8: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;sys/file.h&gt;</span>   <span style="color: #888a85;">/* </span><span style="color: #888a85;">for O_NONBLOCK and FASYNC </span><span style="color: #888a85;">*/</span>
<span class="linenr">  9: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;signal.h&gt;</span>     <span style="color: #888a85;">/* </span><span style="color: #888a85;">for signal() and SIGALRM </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 10: </span><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;errno.h&gt;</span>      <span style="color: #888a85;">/* </span><span style="color: #888a85;">for errno </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 11: </span>
<span class="linenr"> 12: </span><span style="color: #729fcf;">#define</span> <span style="color: #eeeeec;">ECHOMAX</span> 255     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Longest string to echo </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 13: </span>
<span class="linenr"> 14: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">DieWithError</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">errorMessage</span>);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Error handling function </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 15: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">UseIdleTime</span>();                     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Function to use idle time </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 16: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">SIGIOHandler</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">signalType</span>);      <span style="color: #888a85;">/* </span><span style="color: #888a85;">Function to handle SIGIO </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 17: </span>
<span class="linenr"> 18: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sock</span>;                        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Socket -- GLOBAL for signal handler </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 19: </span>
<span class="linenr"> 20: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
<span class="linenr"> 21: </span>{
<span class="linenr"> 22: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">echoServAddr</span>; <span style="color: #888a85;">/* </span><span style="color: #888a85;">Server address </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 23: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">short</span> <span style="color: #eeeeec;">echoServPort</span>;     <span style="color: #888a85;">/* </span><span style="color: #888a85;">Server port </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 24: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sigaction</span> <span style="color: #eeeeec;">handler</span>;        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Signal handling action definition </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 25: </span>
<span class="linenr"> 26: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Test for correct number of parameters </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 27: </span>    <span style="color: #729fcf;">if</span> (argc != 2)
<span class="linenr"> 28: </span>    {
<span class="linenr"> 29: </span>        fprintf(stderr,<span style="color: #ad7fa8;">"Usage:  %s &lt;SERVER PORT&gt;\n"</span>, argv[0]);
<span class="linenr"> 30: </span>        exit(1);
<span class="linenr"> 31: </span>    }
<span class="linenr"> 32: </span>
<span class="linenr"> 33: </span>    echoServPort = atoi(argv[1]);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">First arg:  local port </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 34: </span>
<span class="linenr"> 35: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Create socket for sending/receiving datagrams </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 36: </span>    <span style="color: #729fcf;">if</span> ((sock = socket(PF_INET, SOCK_DGRAM, IPPROTO_UDP)) &lt; 0)
<span class="linenr"> 37: </span>        DieWithError(<span style="color: #ad7fa8;">"socket() failed"</span>);
<span class="linenr"> 38: </span>
<span class="linenr"> 39: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Set up the server address structure </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 40: </span>    memset(&amp;echoServAddr, 0, <span style="color: #729fcf;">sizeof</span>(echoServAddr));   <span style="color: #888a85;">/* </span><span style="color: #888a85;">Zero out structure </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 41: </span>    echoServAddr.sin_family = AF_INET;                <span style="color: #888a85;">/* </span><span style="color: #888a85;">Internet family </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 42: </span>    echoServAddr.sin_addr.s_addr = htonl(INADDR_ANY); <span style="color: #888a85;">/* </span><span style="color: #888a85;">Any incoming interface </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 43: </span>    echoServAddr.sin_port = htons(echoServPort);      <span style="color: #888a85;">/* </span><span style="color: #888a85;">Port </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 44: </span>
<span class="linenr"> 45: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Bind to the local address </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 46: </span>    <span style="color: #729fcf;">if</span> (bind(sock, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *) &amp;echoServAddr, <span style="color: #729fcf;">sizeof</span>(echoServAddr)) &lt; 0)
<span class="linenr"> 47: </span>        DieWithError(<span style="color: #ad7fa8;">"bind() failed"</span>);
<span class="linenr"> 48: </span>
<span class="linenr"> 49: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Set signal handler for SIGIO </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 50: </span>    handler.sa_handler = SIGIOHandler;
<span class="linenr"> 51: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Create mask that mask all signals </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 52: </span>    <span style="color: #729fcf;">if</span> (sigfillset(&amp;handler.sa_mask) &lt; 0)
<span class="linenr"> 53: </span>        DieWithError(<span style="color: #ad7fa8;">"sigfillset() failed"</span>);
<span class="linenr"> 54: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">No flags </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 55: </span>    handler.sa_flags = 0;
<span class="linenr"> 56: </span>
<span class="linenr"> 57: </span>    <span style="color: #729fcf;">if</span> (sigaction(SIGIO, &amp;handler, 0) &lt; 0)
<span class="linenr"> 58: </span>        DieWithError(<span style="color: #ad7fa8;">"sigaction() failed for SIGIO"</span>);
<span class="linenr"> 59: </span>
<span class="linenr"> 60: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">We must own the socket to receive the SIGIO message </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 61: </span>    <span style="color: #729fcf;">if</span> (fcntl(sock, F_SETOWN, getpid()) &lt; 0)
<span class="linenr"> 62: </span>        DieWithError(<span style="color: #ad7fa8;">"Unable to set process owner to us"</span>);
<span class="linenr"> 63: </span>
<span class="linenr"> 64: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Arrange for nonblocking I/O and SIGIO delivery </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 65: </span>    <span style="color: #729fcf;">if</span> (fcntl(sock, F_SETFL, O_NONBLOCK | FASYNC) &lt; 0)
<span class="linenr"> 66: </span>        DieWithError(<span style="color: #ad7fa8;">"Unable to put client sock into non-blocking/async mode"</span>);
<span class="linenr"> 67: </span>
<span class="linenr"> 68: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Go off and do real work; echoing happens in the background </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 69: </span>
<span class="linenr"> 70: </span>    <span style="color: #729fcf;">for</span> (;;)
<span class="linenr"> 71: </span>        UseIdleTime();
<span class="linenr"> 72: </span>
<span class="linenr"> 73: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">NOTREACHED </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 74: </span>}
<span class="linenr"> 75: </span>
<span class="linenr"> 76: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">UseIdleTime</span>()
<span class="linenr"> 77: </span>{
<span class="linenr"> 78: </span>    printf(<span style="color: #ad7fa8;">".\n"</span>);
<span class="linenr"> 79: </span>    sleep(3);     <span style="color: #888a85;">/* </span><span style="color: #888a85;">3 seconds of activity </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 80: </span>}
<span class="linenr"> 81: </span>
<span class="linenr"> 82: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">SIGIOHandler</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">signalType</span>)
<span class="linenr"> 83: </span>{
<span class="linenr"> 84: </span>    <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">echoClntAddr</span>;  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Address of datagram source </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 85: </span>    <span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">clntLen</span>;             <span style="color: #888a85;">/* </span><span style="color: #888a85;">Address length </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 86: </span>    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">recvMsgSize</span>;                  <span style="color: #888a85;">/* </span><span style="color: #888a85;">Size of datagram </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 87: </span>    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">echoBuffer</span>[ECHOMAX];         <span style="color: #888a85;">/* </span><span style="color: #888a85;">Datagram buffer </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 88: </span>
<span class="linenr"> 89: </span>    <span style="color: #729fcf;">do</span>  <span style="color: #888a85;">/* </span><span style="color: #888a85;">As long as there is input... </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 90: </span>    {
<span class="linenr"> 91: </span>        <span style="color: #888a85;">/* </span><span style="color: #888a85;">Set the size of the in-out parameter </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 92: </span>        clntLen = <span style="color: #729fcf;">sizeof</span>(echoClntAddr);
<span class="linenr"> 93: </span>
<span class="linenr"> 94: </span>        <span style="color: #729fcf;">if</span> ((recvMsgSize = recvfrom(sock, echoBuffer, ECHOMAX, 0,
<span class="linenr"> 95: </span>                                    (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *) &amp;echoClntAddr, &amp;clntLen)) &lt; 0)
<span class="linenr"> 96: </span>        {
<span class="linenr"> 97: </span>            <span style="color: #888a85;">/* </span><span style="color: #888a85;">Only acceptable error: recvfrom() would have blocked </span><span style="color: #888a85;">*/</span>
<span class="linenr"> 98: </span>            <span style="color: #729fcf;">if</span> (errno != EWOULDBLOCK)
<span class="linenr"> 99: </span>                DieWithError(<span style="color: #ad7fa8;">"recvfrom() failed"</span>);
<span class="linenr">100: </span>        }
<span class="linenr">101: </span>        <span style="color: #729fcf;">else</span>
<span class="linenr">102: </span>        {
<span class="linenr">103: </span>            printf(<span style="color: #ad7fa8;">"Handling client %s\n"</span>, inet_ntoa(echoClntAddr.sin_addr));
<span class="linenr">104: </span>
<span class="linenr">105: </span>            <span style="color: #729fcf;">if</span> (sendto(sock, echoBuffer, recvMsgSize, 0, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)
<span class="linenr">106: </span>                       &amp;echoClntAddr, <span style="color: #729fcf;">sizeof</span>(echoClntAddr)) != recvMsgSize)
<span class="linenr">107: </span>                DieWithError(<span style="color: #ad7fa8;">"sendto() failed"</span>);
<span class="linenr">108: </span>        }
<span class="linenr">109: </span>    }  <span style="color: #729fcf;">while</span> (recvMsgSize &gt;= 0);
<span class="linenr">110: </span>    <span style="color: #888a85;">/* </span><span style="color: #888a85;">Nothing left to receive </span><span style="color: #888a85;">*/</span>
<span class="linenr">111: </span>}
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">多任务处理</h2>
<div class="outline-text-2" id="text-orgheadline10">
</div><div id="outline-container-orgheadline28" class="outline-3">
<h3 id="orgheadline28">迭代服务器与并发服务器</h3>
<div class="outline-text-3" id="text-orgheadline28">
<p>
一个最简单的服务器实现，是一次只能处理一个客户端请求的，且只能顺序处理客户端的请求，这种最简单的服务器被称为“迭代服务器(iterative servers)”。
</p>

<p>
这种服务器无法充分利用多核CPU，不适合处理时间较长的连接，否则对于其他客户端而言，等待的时间将无法忍受。
</p>

<p>
另一种服务器模式则能够“同时”处理多个客户端的连接请求，这种服务器被称为“并发服务器(concurrent servers)”。并发服务器的模型有：一客户端一进程、一客户端一线程以及约束多任务。
</p>
</div>
</div>

<div id="outline-container-orgheadline29" class="outline-3">
<h3 id="orgheadline29">一客户端一进程</h3>
<div class="outline-text-3" id="text-orgheadline29">
<p>
当检查到客户端请求时，服务器创建一个子进程来处理连接请求。在Unix/Linux下，通常是调用fork()来做这件事情。要注意的是，在父进程中应该调用waitpid()来为子进程“收尸”，并且在父进程中应该关闭子套接字(accept()得到的套接字)，在子进程中应该关闭监听套接字。
</p>

<p>
有时候也需要在子进程中获取连接的信息，如IP地址以及端口号，而采用现在所说的模型时，子进程是不能直接得到这些信息的(accept()只在父进程中执行)，这时可以使用以下两个函数：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">getpeername</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">addr</span>, <span style="color: #8ae234;">socklen_t</span> *<span style="color: #eeeeec;">addrlen</span>);
<span class="linenr">2: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">getsockname</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>, <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *<span style="color: #eeeeec;">addr</span>, <span style="color: #8ae234;">socklen_t</span> *<span style="color: #eeeeec;">addrlen</span>);
</pre>
</div>
<p>
前者用来获取和指定套接字连接的另一端的地址信息，后者用来获取本地的地址信息。
</p>
</div>
</div>

<div id="outline-container-orgheadline30" class="outline-3">
<h3 id="orgheadline30">一客户端一线程</h3>
<div class="outline-text-3" id="text-orgheadline30">
<p>
为每个客户端连接请求建立子进程具有编码简单的优点，但对资源的消耗比较大。从这个角度来考虑，使用线程可以节省资源、提高效率。不过线程模式会使编程难度增大，因为多线程中必须要考虑数据同步和互斥的情况。
</p>

<p>
不管是之前的为每个客户端请求建立一个子进程的模式还是现在说的为每个客户端请求建立线程的模式，它们都更适用于少量客户端的情况，因为在同一个系统中，进程数和线程数都是有限的，而且在不同进程/线程之间切换的开销也会随着进程数/线程数的增大而升高。
</p>
</div>
</div>

<div id="outline-container-orgheadline31" class="outline-3">
<h3 id="orgheadline31">进程池和线程池</h3>
<div class="outline-text-3" id="text-orgheadline31">
<p>
所谓的“约束多任务”就是为了解决上面两种模式的问题而建立的模型。这种模型的思想是，预先建立若干个子进程/子线程，然后在多个子进程/子线程中来处理多个客户端连接请求。
</p>

<p>
注意该模式和之前两种模式的区别。拿多进程模式来说，是先accept()得到客户端连接请求后，再建立子进程来进行处理；而进程池，则是先创建子进程，然后在子进程能够中监听客户端的连接请求。
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline11" class="outline-2">
<h2 id="orgheadline11">多路复用</h2>
<div class="outline-text-2" id="text-orgheadline11">
<p>
多路复用也是socket编程中常用到的一种模型。
</p>

<p>
在最简单的socket模型中，一旦建立连接，随后就会进行数据的接收/发送，而当缓冲区中为空/已满时，将会阻塞。在只有单个连接的时候，这样的简单模型也是可用的。但当实际应用需要同时处理大量连接时，一个阻塞的连接将会导致来自其他地址的连接进入等待状态。
</p>

<p>
之前提到的几种方式也可以解决这个问题，如使用信号机制或多任务机制。除此以外还可以使用“多路复用”技术来解决这个问题。
</p>

<p>
使用select()可以做到这件事情。使用select()时，select()检查给定的一个socket描述符集合，当没有可用的socket时，在select()中阻塞(而不是在真正的I/O操作中阻塞)，直到发现可用的socket时，select()就返回。程序这时就可以对那些可用的socket进行操作。
</p>

<p>
select()的原型为：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">select</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">nfds</span>, <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">readfds</span>, <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">writefds</span>,
<span class="linenr">2: </span>           <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">exceptfds</span>, <span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">timeval</span> *<span style="color: #eeeeec;">timeout</span>);
</pre>
</div>
<p>
其中中间三个参数都是socket描述符的集合。readfds指向的socket描述符集合被检查是否可读，writefds指向的socket描述符集合被检查是否科协，exceptfds指向的集合被检查是否有特殊情况发生。
</p>

<p>
系统提供了四个宏对socket描述符集合进行操作，它们是：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">FD_ZERO</span>(<span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">set</span>);         <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#23558;&#38598;&#21512;&#28165;&#31354; </span><span style="color: #888a85;">*/</span>
<span class="linenr">2: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">FD_CLR</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">fd</span>, <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">set</span>);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#23558;socket&#25551;&#36848;&#31526;&#20174;&#38598;&#21512;&#20013;&#31227;&#38500; </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span><span style="color: #8ae234;">void</span> <span style="color: #edd400;">FD_SET</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">fd</span>, <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">set</span>);  <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#23558;socket&#25551;&#36848;&#31526;&#21152;&#20837;&#38598;&#21512; </span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span><span style="color: #8ae234;">int</span> <span style="color: #edd400;">FD_ISSET</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">fd</span>, <span style="color: #8ae234;">fd_set</span> *<span style="color: #eeeeec;">set</span>); <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#21028;&#26029;socket&#25551;&#36848;&#31526;&#26159;&#21542;&#38598;&#21512;&#25104;&#21592; </span><span style="color: #888a85;">*/</span>
</pre>
</div>

<p>
第一个参数必须是所有要监视的socket描述符中最大值加1后得到的值，注意，是 <b>所有</b> ，即三个socket描述符集合都要考虑到。
</p>

<p>
最后一个参数设定了select()等待的时间上限，即在等待时间内所监视的socket描述符集合中都没有可用的，则判定为超时，select()在这种情况下会直接返回而不再等待。
</p>

<p>
结构timeval如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">timeval</span> {
<span class="linenr">2: </span>    <span style="color: #8ae234;">time_t</span> <span style="color: #eeeeec;">tv_sec</span>;              <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#31186; </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>    <span style="color: #8ae234;">time_t</span> <span style="color: #eeeeec;">tv_usec</span>;             <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#24494;&#31186; </span><span style="color: #888a85;">*/</span>
<span class="linenr">4: </span>};
</pre>
</div>

<p>
如果指定时间内没有任何socket可用，select()返回0。否则返回可用的socket数量，并且在相应的socket描述符集合中 <b>只保留可用的socket描述符</b> ，因此在select()检测到可用的socket并返回后，可以用宏 <b>FD_ISSET</b> 来检查具体有哪些socket可用。
</p>

<p>
如果发生错误，select()返回-1并设置错误变量 <b>errno</b> 。
</p>

<p>
因为socket描述符实际上是文件描述符，因此采用多路复用技术时，还可以检测有无键盘输入。
</p>

<p>
select()有其自身缺陷，如它采用主动轮询的方式，逐个检查集合中的socket描述符，直到发现可用的socket，因此效率不高；且select()可以监视的连接数是有限的，因为系统的文件描述符是有限的(通常是1024)。
</p>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-2">
<h2 id="orgheadline12">单播、多播和广播</h2>
<div class="outline-text-2" id="text-orgheadline12">
<ul class="org-ul">
<li><p>
单播
</p>

<p>
单播(unicast)是一对一的通信，也就是点对点通信。在这之前提到及实现的socket连接都是单播的。
</p></li>
<li><p>
广播
</p>

<p>
有些时候需要同时和多个地址进行通信，如果采用单播的方式，那就需要建立多条连接，并且在多条连接里发送多份同样的数据，这无疑是对带宽的浪费。通过使用UDP，可以将发送数据到多个接收者那里的工作交给网络，其中广播(broadcast)是常用的一种方式，即将数据发送到同一网络下的所有地址——一般都是指子网广播，全网广播理论上来说也可以，但是路由器通常会过滤掉这种全网广播。
</p>

<p>
由于TCP连接必须指定连接双方的具体地址，广播(和多播)都只能通过UDP来实现。
</p>

<p>
通过UDP实现广播，和实现单播只有几处不同。
</p>

<p>
首先，在具体实现中，要调用setsockopt()来将socket设置为广播属性，形式如下：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">braodcast</span> = 1;
<span class="linenr">2: </span>setsockopt(sockfd, SOL_SOCKET, SO_BROADCAST,
<span class="linenr">3: </span>           (<span style="color: #8ae234;">void</span> *)&amp;broadcast, <span style="color: #729fcf;">sizeof</span>(broadcast));
</pre>
</div>
<p>
其次，要设置信息接收方的IP地址为广播地址。
</p>

<p>
对于广播信息的接收方，除了将要接收的地址设置为 <b>INADDR_ANY</b> 外，与单播的UDP接收实现并无太多。即广播信息的接收方，大致是这样的：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr"> 1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span>;
<span class="linenr"> 2: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">broadcast_addr</span>;
<span class="linenr"> 3: </span><span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">port</span>=8888;
<span class="linenr"> 4: </span><span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">msg</span>[256];
<span class="linenr"> 5: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">msg_len</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>sockfd = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
<span class="linenr"> 8: </span>
<span class="linenr"> 9: </span>bzero(&amp;broadcast_addr, <span style="color: #729fcf;">sizeof</span>(broadcast_addr));
<span class="linenr">10: </span>broadcast_addr.sin_family = AF_INET;
<span class="linenr">11: </span>broadcast_addr.sin_addr.s_addr = htonl(INADDR_ANY);
<span class="linenr">12: </span>broadcast_addr.sin_port = htons(port);
<span class="linenr">13: </span>
<span class="linenr">14: </span>bind(sockfd, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)&amp;broadcast_addr,
<span class="linenr">15: </span>     <span style="color: #729fcf;">sizeof</span>(broadcast_addr));
<span class="linenr">16: </span>
<span class="linenr">17: </span>msg_len = recvfrom(sockfd, msg, <span style="color: #729fcf;">sizeof</span>(msg), 0, <span style="color: #e6a00f;">NULL</span>, 0);
</pre>
</div></li>
<li><p>
多播
</p>

<p>
多播(Mluticast)，也被称作“组播”。
</p>

<p>
组播也单播类似，区别在于地址形式。发送组播信息必须使用组播地址，即以”1110“作为网络标识符的D类地址
</p>

<p>
类似广播，要实现组播，也要调用setsockopt():
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span> = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
<span class="linenr">2: </span><span style="color: #8ae234;">unsigned</span> <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">ttl</span>;
<span class="linenr">3: </span>setsockfd(sockfd, IPPROTO_IP, IP_MULTICAST_TTL, (<span style="color: #8ae234;">void</span> *)&amp;ttl);
</pre>
</div>
<p>
和广播的不同之处在于，组播不需要将socket设置为组播属性，但组播需要设置TTL。
</p>

<p>
在接收方，稍微有一点复杂。所谓组播地址是一些共享地址，如果要能够接收组播信息，接收方必须得加入组播组。因此组播信息的接收方的实现大致如下：
</p>

<p>
首先创建的socket也必须是UDP socket:
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">sockfd</span> = socket(AF_INET, SOCK_DGRAM, IPPROTO_UDP);
</pre>
</div>
<p>
然后要绑定组播端口，并设置为接收所有发送到该端口的信息：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr_in</span> <span style="color: #eeeeec;">multi_addr</span>;
<span class="linenr">2: </span>multi_addr.sin_family = AF_INET;
<span class="linenr">3: </span>multi_addr.sin_addr.s_addr = htonl(INADDR_ANY);
<span class="linenr">4: </span>multi_addr.sin_port = htons(PORT);
<span class="linenr">5: </span>bind(sockfd, (<span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">sockaddr</span> *)&amp;multi_addr, <span style="color: #729fcf;">sizeof</span>(multi_addr));
</pre>
</div>
<p>
还要加入组播组：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #729fcf;">struct</span> <span style="color: #8ae234;">ip_mreq</span> <span style="color: #eeeeec;">multi_request</span>;
<span class="linenr">2: </span>multi_request.imr_multiaddr.s_addr = inet_addr(multi_addr); <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#19982;&#21457;&#36865;&#26041;&#19968;&#33268; </span><span style="color: #888a85;">*/</span>
<span class="linenr">3: </span>multi_request.imr_interface.s_addr = htonl(INADDR_ANY);
<span class="linenr">4: </span>setsockopt(sockfd, IPPROTO_IP, IP_ADD_MEMBERSHIP, <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#21152;&#20837;&#32452;&#25773;&#32452; </span><span style="color: #888a85;">*/</span>
<span class="linenr">5: </span>           (<span style="color: #8ae234;">void</span> *)&amp;multi_request, <span style="color: #729fcf;">sizeof</span>(multi_request));
</pre>
</div>
<p>
这之后如果不出错就可以进行信息的接收了：
</p>
<div class="org-src-container">

<pre class="src src-C"><span class="linenr">1: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">msg</span>[256];
<span class="linenr">2: </span><span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">msg_len</span>;
<span class="linenr">3: </span>
<span class="linenr">4: </span>msg_len = recvfrom(sockfd, msg, <span style="color: #729fcf;">sizeof</span>(msg), 0, <span style="color: #e6a00f;">NULL</span>, 0);
</pre>
</div></li>
</ul>
</div>
</div>

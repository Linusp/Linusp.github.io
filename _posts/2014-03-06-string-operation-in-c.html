---
layout     : post
title      : C语言字符串操作
categories : 编程
tags       :
- C/C++
- 字符串
description:
---

<div id="table-of-contents">
<h2>&#30446;&#24405;</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#orgheadline1">string.h</a></li>
<li><a href="#orgheadline2">字符串拷贝(strcpy, strncpy)</a>
<ul>
<li><a href="#orgheadline3">strcpy</a></li>
<li><a href="#orgheadline4">strncpy</a></li>
</ul>
</li>
<li><a href="#orgheadline5">字符串比较(strcmp, strncmp, strcasecmp, strncasecmp)</a>
<ul>
<li><a href="#orgheadline6">strcmp</a></li>
<li><a href="#orgheadline7">strncmp</a></li>
<li><a href="#orgheadline8">strcasecmp</a></li>
<li><a href="#orgheadline9">strncasecmp</a></li>
</ul>
</li>
<li><a href="#orgheadline10">字符串连接(strcat, strncat)</a>
<ul>
<li><a href="#orgheadline11">strcat</a></li>
<li><a href="#orgheadline12">strncat</a></li>
</ul>
</li>
<li><a href="#orgheadline13">字符查找(strchr, strrchr, strchrnul, strpbrk)</a>
<ul>
<li><a href="#orgheadline14">strchr</a></li>
<li><a href="#orgheadline15">strrchr</a></li>
<li><a href="#orgheadline16">strchrnul</a></li>
<li><a href="#orgheadline17">strpbrk</a></li>
</ul>
</li>
<li><a href="#orgheadline18">字符串分割(strtok, strtok_r, strsep)</a>
<ul>
<li><a href="#orgheadline19">strtok</a></li>
<li><a href="#orgheadline20">strtok_r</a></li>
<li><a href="#orgheadline21">strsep</a></li>
</ul>
</li>
<li><a href="#orgheadline22">字符串匹配(strstr)</a></li>
<li><a href="#orgheadline23">字符串副本创建(strdup, strndup, strdupa, strndupa)</a>
<ul>
<li><a href="#orgheadline24">strdup</a></li>
<li><a href="#orgheadline25">strndup</a></li>
<li><a href="#orgheadline26">strdupa</a></li>
<li><a href="#orgheadline27">strndupa</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-orgheadline1" class="outline-2">
<h2 id="orgheadline1">string.h</h2>
<div class="outline-text-2" id="text-orgheadline1">
<p>
其实在C语言的标准库中，也有非常丰富的字符串操作函数。当然了，由于C语言中 <b>字符串</b> 并不是基本数据类型，也没有 <b>类</b> 这个概念，相对来说操作上可能没有Python/Java之类的语言方便。不过了解一下C语言中的字符串操作还是有意义的。
</p>

<p>
C语言中的字符串操作函数在 <b>string.h</b> 中，不过要了解都有什么函数，阅读string.h并不是什么好的方式。如果是在Unix/Linux系统下，只要执行：
</p>
<div class="org-src-container">

<pre class="src src-sh">man string
</pre>
</div>
<p>
就可以了解都有哪些字符串操作函数了，如下图所示：
</p>


<div class="figure">
<p><img src="/assets/img/string_manual.png" alt="string_manual.png" />
</p>
</div>

<p>
其中一些常用的函数及其大致功能如下(具体细节后面再细说)：
</p>
<ul class="org-ul">
<li><p>
字符串拷贝
</p>

<p>
stcpy, strncpy
</p></li>
<li><p>
字符串比较
</p>

<p>
strcmp, strncmp, strcasecmp, strncasecmp
</p></li>
<li><p>
字符串连接
</p>

<p>
strcat, strncat
</p></li>
<li><p>
字符查找
</p>

<p>
strchr, strrchr, strchrnul, strpbrk
</p></li>
<li><p>
建立字符串副本
</p>

<p>
strdup, strndup, strdupa, strndupa
</p></li>
<li><p>
字符串分割
</p>

<p>
strsep, strtok, strtok_r
</p></li>
<li><p>
字符串匹配
</p>

<p>
strstr
</p></li>
</ul>


<p>
下面根据功能的不同来展示各个函数的用法。这里我会用一些实例来进行示范，同时，其结果由org-babel对代码块求值得到。
</p>
</div>
</div>
<div id="outline-container-orgheadline2" class="outline-2">
<h2 id="orgheadline2">字符串拷贝(strcpy, strncpy)</h2>
<div class="outline-text-2" id="text-orgheadline2">
</div><div id="outline-container-orgheadline3" class="outline-3">
<h3 id="orgheadline3">strcpy</h3>
<div class="outline-text-3" id="text-orgheadline3">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strcpy</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dest</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span>);
</pre>
</div>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">dest</span>[1024] = {0};
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span> = <span style="color: #ad7fa8;">"abcde"</span>;

    strcpy(dest, src);

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, dest);
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
abcde
</pre>

<p>
strcpy()函数会将源字符串中的结束符('\0')也拷贝到目的字符串中。
</p>

<p>
注意，strcpy()可能会导致溢出。
</p>
</div>
</div>
<div id="outline-container-orgheadline4" class="outline-3">
<h3 id="orgheadline4">strncpy</h3>
<div class="outline-text-3" id="text-orgheadline4">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strncpy</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dest</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">n</span>);
</pre>
</div>

<p>
该函数从源字符串中拷贝n个字符到目的字符串；如果源字符串长度不足，则用 <b>NULL</b> 填充，以保证将n个字符写入目的字符串中；如果源字符串中前n个字符不包含字符串结束符，函数不会为目的字符串添加上结束符。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">dest</span>[7] = {0};
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span> = <span style="color: #ad7fa8;">"abcde"</span>;

    dest[5] = <span style="color: #ad7fa8;">'A'</span>;
    strncpy(dest, src, 5);

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, dest);
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
abcdeA
</pre>

<p>
所以如果有需要，应该在拷贝后自己在目的字符串尾部添加结束符。
</p>
</div>
</div>
</div>

<div id="outline-container-orgheadline5" class="outline-2">
<h2 id="orgheadline5">字符串比较(strcmp, strncmp, strcasecmp, strncasecmp)</h2>
<div class="outline-text-2" id="text-orgheadline5">
</div><div id="outline-container-orgheadline6" class="outline-3">
<h3 id="orgheadline6">strcmp</h3>
<div class="outline-text-3" id="text-orgheadline6">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">int</span> <span style="color: #edd400;">strcmp</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span>);
</pre>
</div>
<p>
如果s1小于s2，函数返回一个负数；如果s1等于s2，函数返回0；否则返回一个正数。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span> = <span style="color: #ad7fa8;">"abcde"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span> = <span style="color: #ad7fa8;">"abcef"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s3</span> = <span style="color: #ad7fa8;">"ad"</span>;

    printf(<span style="color: #ad7fa8;">"compare(%s, %s) -&gt; %d\n"</span>, s1, s2, strcmp(s1, s2));
    printf(<span style="color: #ad7fa8;">"compare(%s, %s) -&gt; %d\n"</span>, s1, s3, strcmp(s1, s3));
    printf(<span style="color: #ad7fa8;">"compare(%s, %s) -&gt; %d\n"</span>, s2, s3, strcmp(s2, s3));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
compare(abcde, abcef) -&gt; -1
compare(abcde, ad) -&gt; -2
compare(abcef, ad) -&gt; -2
</pre>

<p>
从这个结果可以发现，strcmp()是根据字典序来对字符串进行比较的。进一步的，还可以发现strcmp()的返回值是比较过程中最后一次比较时两个字符的值的差，如比较"abcde"和"abcef"，有：
</p>
<pre class="example">
a - a = 0
b - b = 0
c - c = 0
d - e = -1 #按字典序，大小已分，不再比较
</pre>
</div>
</div>

<div id="outline-container-orgheadline7" class="outline-3">
<h3 id="orgheadline7">strncmp</h3>
<div class="outline-text-3" id="text-orgheadline7">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">int</span> <span style="color: #edd400;">strncmp</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">n</span>);
</pre>
</div>

<p>
和strcmp()的区别是，strncmp()只对s1和s2的前n个字节进行比较。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span> = <span style="color: #ad7fa8;">"abcde"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span> = <span style="color: #ad7fa8;">"abcfg"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s3</span> = <span style="color: #ad7fa8;">"abd"</span>;

    printf(<span style="color: #ad7fa8;">"compare(%s, %s, 4) -&gt; %d\n"</span>, s1, s2, strncmp(s1, s2, 4));
    printf(<span style="color: #ad7fa8;">"compare(%s, %s, 2) -&gt; %d\n"</span>, s1, s3, strncmp(s1, s3, 2));
    printf(<span style="color: #ad7fa8;">"compare(%s, %s, 3) -&gt; %d\n"</span>, s2, s3, strncmp(s2, s3, 3));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
compare(abcde, abcfg, 4) -&gt; -2
compare(abcde, abd, 2) -&gt; 0
compare(abcfg, abd, 3) -&gt; -1
</pre>
</div>
</div>

<div id="outline-container-orgheadline8" class="outline-3">
<h3 id="orgheadline8">strcasecmp</h3>
<div class="outline-text-3" id="text-orgheadline8">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">int</span> <span style="color: #edd400;">strcasecmp</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span>);
</pre>
</div>

<p>
strcasecmp()也是用来比较字符串的，和strcmp()有两点区别：
</p>
<ol class="org-ol">
<li>使用strcasecmp()应该包含 <b>strings.h</b> 而不是 <b>string.h</b></li>
<li>strcasecmp()在比较时不区分大小写</li>
</ol>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;strings.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s1</span> = <span style="color: #ad7fa8;">"AbcdE"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s2</span> = <span style="color: #ad7fa8;">"abcdE"</span>;

    printf(<span style="color: #ad7fa8;">"compare(%s, %s) with case -&gt; %d\n"</span>, s1, s2, strcmp(s1, s2));
    printf(<span style="color: #ad7fa8;">"compare(%s, %s) ignore case -&gt; %d\n"</span>, s1, s2, strcasecmp(s1, s2));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
compare(AbcdE, abcdE) with case -&gt; -32
compare(AbcdE, abcdE) ignore case -&gt; 0
</pre>
</div>
</div>

<div id="outline-container-orgheadline9" class="outline-3">
<h3 id="orgheadline9">strncasecmp</h3>
<div class="outline-text-3" id="text-orgheadline9">
<p>
strncasecmp()之于strcasecmp()就如strncmp()之于strcmp()，不再赘述。
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline10" class="outline-2">
<h2 id="orgheadline10">字符串连接(strcat, strncat)</h2>
<div class="outline-text-2" id="text-orgheadline10">
</div><div id="outline-container-orgheadline11" class="outline-3">
<h3 id="orgheadline11">strcat</h3>
<div class="outline-text-3" id="text-orgheadline11">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strcat</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dest</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span>);
</pre>
</div>

<p>
strcat()首先会覆盖掉目的字符串的结束符，然后把源字符串的内容追加到后面，并在最后添加结束符。如果目的字符串缓冲区长度不够，将导致溢出。
</p>

<p>
strcat()在操作完成后，返回目的字符串的首地址，这样可以方便地进行链式操作。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">dest</span>[1024] = <span style="color: #ad7fa8;">"hello "</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span> = <span style="color: #ad7fa8;">"world!"</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strcat(dest, src));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
hello world!
</pre>
</div>
</div>

<div id="outline-container-orgheadline12" class="outline-3">
<h3 id="orgheadline12">strncat</h3>
<div class="outline-text-3" id="text-orgheadline12">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strncat</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dest</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">n</span>);
</pre>
</div>

<p>
strncat()将最多n个字节的内容追加到目的字符串尾部，并且会在追加后添加终止符号。
</p>

<p>
同strcat()一样，它返回目的字符串的首地址。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">dest</span>[1024] = <span style="color: #ad7fa8;">"hello "</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">src</span> = <span style="color: #ad7fa8;">"world!lkjsdljsd"</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strncat(dest, src, 6));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
hello world!
</pre>
</div>
</div>
</div>

<div id="outline-container-orgheadline13" class="outline-2">
<h2 id="orgheadline13">字符查找(strchr, strrchr, strchrnul, strpbrk)</h2>
<div class="outline-text-2" id="text-orgheadline13">
</div><div id="outline-container-orgheadline14" class="outline-3">
<h3 id="orgheadline14">strchr</h3>
<div class="outline-text-3" id="text-orgheadline14">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strchr</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">c</span>);
</pre>
</div>

<p>
strchr()返回一个字符指针，指向指定字符在指定字符串中第一次出现的位置。如果在指定字符串中没有找到指定字符，则返回 <b>NULL</b> 。该函数的第二个参数按理来说应当是一个字符，不过标准库中确实是int类型。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"hello world!"</span>;
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">c</span> = <span style="color: #ad7fa8;">'l'</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strchr(s, c));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
llo world!
</pre>
</div>
</div>
<div id="outline-container-orgheadline15" class="outline-3">
<h3 id="orgheadline15">strrchr</h3>
<div class="outline-text-3" id="text-orgheadline15">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strrchr</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">c</span>);
</pre>
</div>

<p>
strrchr()和strchr()类似，但它返回的是指定字符在指定字符串中最后一次出现的位置。如果未找到，同样返回 <b>NULL</b> 。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"hello world!"</span>;
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">c</span> = <span style="color: #ad7fa8;">'l'</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strrchr(s, c));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
ld!
</pre>
</div>
</div>
<div id="outline-container-orgheadline16" class="outline-3">
<h3 id="orgheadline16">strchrnul</h3>
<div class="outline-text-3" id="text-orgheadline16">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strchrnul</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">c</span>);
</pre>
</div>

<p>
strchrnul()的功能和strchr()只有细微的区别，那就是，当没有找到指定字符时，strchrnul()不返回 <b>NULL</b> ，而是返回字符串结束符的位置。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"abcde"</span>;
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">c</span> = <span style="color: #ad7fa8;">'m'</span>;

    printf(<span style="color: #ad7fa8;">"%p, %p\n"</span>, s, strchrnul(s, c));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果
</p>
<pre class="example">
0x40065c, 0x400661
</pre>

<p>
这里由于strchrnul()的特性，没办法通过打印字符串来了解strchrnul()的操作，不过观察这两个指针的值，会发现：
</p>
<pre class="example">
0x400661 - 0x40065c = 0x5
</pre>
<p>
而字符串s的第六个元素(从0开始，5即第六个)，正好是结束符。
</p>
</div>
</div>
<div id="outline-container-orgheadline17" class="outline-3">
<h3 id="orgheadline17">strpbrk</h3>
<div class="outline-text-3" id="text-orgheadline17">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strpbrk</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">accept</span>);
</pre>
</div>

<p>
strpbrk()和strchr()的区别在于，strchr()是从字符串里搜索 <b>一个字符</b> ，而strpbrk()则是在字符串里搜索 <b>一个字符集中的字符</b> ，看第二个参数就明白了。strpbrk()遍历字符串，如果发现某个字符在指定的 <b>字符集</b> 中，则立即返回指向该字符的指针。如果最后没有找到任何在指定字符集中的字符，则返回 <b>NULL</b> 。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"Hello World!"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">accept</span> = <span style="color: #ad7fa8;">"Wo"</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strpbrk(s, accept));

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
o World!
</pre>
</div>
</div>
</div>
<div id="outline-container-orgheadline18" class="outline-2">
<h2 id="orgheadline18">字符串分割(strtok, strtok_r, strsep)</h2>
<div class="outline-text-2" id="text-orgheadline18">
</div><div id="outline-container-orgheadline19" class="outline-3">
<h3 id="orgheadline19">strtok</h3>
<div class="outline-text-3" id="text-orgheadline19">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strtok</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">str</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delim</span>);
</pre>
</div>

<p>
strtok()根据第二个参数指定的分隔符(可能存在多个不同的分隔符)将指定字符串分割成多个子串。通过多次调用strtok()，可以依次获得字符串的多个子串的首地址。要注意的是，除了第一次调用时将待分割字符串作为第一个参数，后续的调用要将第一个参数置为 <b>NULL</b> 。当字符串已经无法再分割时，strtok()返回 <b>NULL</b> 。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">s</span>[1024] = <span style="color: #ad7fa8;">"abc;lsdk:lskdj,;slsj"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delm</span> = <span style="color: #ad7fa8;">";:,"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">result</span> = <span style="color: #e6a00f;">NULL</span>;
    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">len</span> = strlen(s);
    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">i</span> = 0;

    result = strtok(s, delm);
    <span style="color: #729fcf;">while</span> (result != <span style="color: #e6a00f;">NULL</span>) {
        printf(<span style="color: #ad7fa8;">"Source:%s, Sub:%s\n"</span>, s, result);
        result = strtok(<span style="color: #e6a00f;">NULL</span>, delm);
    }

    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
Source:abc Sub:abc
Source:abc Sub:lsdk
Source:abc Sub:lskdj
Source:abc Sub:slsj
</pre>

<p>
除了上面说过的strtok()的用法外，还要注意的是，作为待分割的字符串，它必须是 <b>可更改的</b> 。否则虽然可以通过编译，但运行会出错。要理解这个现象，首先要了解strtok()的内部机制。
</p>

<p>
了解其机制，没必要去寻找其实现源代码，只要对它的操作过程进行剖析就知道了。先看下面的代码：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>


<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">s</span>[64] = <span style="color: #ad7fa8;">"To be or not to be"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delm</span> = <span style="color: #ad7fa8;">" ,."</span>;         <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#20998;&#38548;&#31526;&#65306;&#31354;&#26684; </span><span style="color: #888a85;">*/</span>
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">result</span> = <span style="color: #e6a00f;">NULL</span>;
    <span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">i</span> = 0, <span style="color: #eeeeec;">len</span> = strlen(s);

    <span style="color: #729fcf;">for</span> (i = 0; i &lt; len; ++i) { <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#36880;&#20010;&#25171;&#21360;s&#20013;&#30340;&#23383;&#31526; </span><span style="color: #888a85;">*/</span>
        printf(<span style="color: #ad7fa8;">"%c "</span>, s[i]);
    }
    printf(<span style="color: #ad7fa8;">"\n"</span>);


    <span style="color: #729fcf;">for</span> (i = 0; i &lt; len; ++i) { <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#36880;&#20010;&#25171;&#21360;s&#20013;&#23383;&#31526;&#30340;&#25968;&#20540; </span><span style="color: #888a85;">*/</span>
        printf(<span style="color: #ad7fa8;">"%d "</span>, (<span style="color: #8ae234;">int</span>)s[i]);
    }
    printf(<span style="color: #ad7fa8;">"\n"</span>);

    result = strtok(s, delm);
    <span style="color: #729fcf;">while</span> (result != <span style="color: #e6a00f;">NULL</span>) {    <span style="color: #888a85;">/* </span><span style="color: #888a85;">&#35266;&#23519;s&#20013;&#23383;&#31526;&#25968;&#20540;&#30340;&#21464;&#21270; </span><span style="color: #888a85;">*/</span>

        <span style="color: #729fcf;">for</span> (i = 0; i &lt; len; ++i) {
            printf(<span style="color: #ad7fa8;">"%d "</span>, (<span style="color: #8ae234;">int</span>)s[i]);
        }
        printf(<span style="color: #ad7fa8;">"\n"</span>);

        result = strtok(<span style="color: #e6a00f;">NULL</span>, delm);
    }
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<tbody>
<tr>
<td class="org-right">T</td>
<td class="org-right">o</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">b</td>
<td class="org-right">e</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">o</td>
<td class="org-right">r</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">n</td>
<td class="org-right">o</td>
<td class="org-right">t</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">t</td>
<td class="org-right">o</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">b</td>
<td class="org-right">e</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">32</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">32</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">32</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">32</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">32</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">32</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">0</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">32</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">32</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">0</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">0</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">32</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">0</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">0</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">0</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">32</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">0</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">0</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">0</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>

<tr>
<td class="org-right">84</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
<td class="org-right">0</td>
<td class="org-right">111</td>
<td class="org-right">114</td>
<td class="org-right">0</td>
<td class="org-right">110</td>
<td class="org-right">111</td>
<td class="org-right">116</td>
<td class="org-right">0</td>
<td class="org-right">116</td>
<td class="org-right">111</td>
<td class="org-right">0</td>
<td class="org-right">98</td>
<td class="org-right">101</td>
</tr>
</tbody>
</table>
<p>
可以看到，s中的分隔符，逐次地被置为'\0'即字符串结束符。这就是strtok()分割字符串的内部原理了。而strtok()返回的指针，其实就是s中各个子串的起始位置了。如果s指向的内容是无法被修改的，那么strtok()自然也就无法将原先的分隔符置为字符结束符了。
</p>

<p>
当然了，由于源字符串会被修改，在实际中，如果需要，可以用strdup()来建立一个源字符串的副本。
</p>
</div>
</div>
<div id="outline-container-orgheadline20" class="outline-3">
<h3 id="orgheadline20">strtok_r</h3>
<div class="outline-text-3" id="text-orgheadline20">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strtok_r</span>(<span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">str</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delim</span>, <span style="color: #8ae234;">char</span> **<span style="color: #eeeeec;">saveptr</span>);
</pre>
</div>

<p>
strtok_r()是Linux下的strtok()的可重入版本(线程安全版本)，它比strtok()多了一个参数 <b>saveptr</b> ，这个参数用于在分割字符串时保存上下文。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">s</span>[64] = <span style="color: #ad7fa8;">"Hello world"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delm</span> = <span style="color: #ad7fa8;">" "</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">result</span> = <span style="color: #e6a00f;">NULL</span>, *<span style="color: #eeeeec;">ptr</span> = <span style="color: #e6a00f;">NULL</span>;

    printf(<span style="color: #ad7fa8;">"Source:%p\n"</span>, s);
    result = strtok_r(s, delm, &amp;ptr);
    <span style="color: #729fcf;">while</span> (result != <span style="color: #e6a00f;">NULL</span>) {
        printf(<span style="color: #ad7fa8;">"Result:%p\t"</span>, result);
        printf(<span style="color: #ad7fa8;">"Saveptr:%p\n"</span>, ptr);
        printf(<span style="color: #ad7fa8;">"---%s\t"</span>, result);
        printf(<span style="color: #ad7fa8;">"---%s\n"</span>, ptr);

        result = strtok_r(<span style="color: #e6a00f;">NULL</span>, delm, &amp;ptr);
    }
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
Source:0x7fff180f3de0
Result:0x7fff180f3de0 Saveptr:0x7fff180f3de6
---Hello              ---world
Result:0x7fff180f3de6 Saveptr:0x7fff180f3deb
---world              ---
</pre>
<p>
可以看到，saveptr这个指针在每次调用strtok_r()后就指向了未分割的部分的首地址。相对地，strtok()则是在内部有一个静态缓冲区，通过这个静态缓冲区来记录未处理的起始位置，所以strtok()不是线程安全的。
</p>
</div>
</div>

<div id="outline-container-orgheadline21" class="outline-3">
<h3 id="orgheadline21">strsep</h3>
<div class="outline-text-3" id="text-orgheadline21">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strsep</span>(<span style="color: #8ae234;">char</span> **<span style="color: #eeeeec;">stringp</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delim</span>);
</pre>
</div>

<p>
strsep()同样是字符串分割函数，它和strtok()的不同之处在于，它会直接修改待分割的指针的值，让它始终指向未处理部分的起始位置。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> <span style="color: #eeeeec;">s</span>[64] = <span style="color: #ad7fa8;">"To be or not to be"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">source</span> = s;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">delm</span> = <span style="color: #ad7fa8;">" "</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">result</span> = <span style="color: #e6a00f;">NULL</span>;

    <span style="color: #729fcf;">while</span> (source != <span style="color: #e6a00f;">NULL</span>) {
        printf(<span style="color: #ad7fa8;">"Source:%s | "</span>, source);
        result = strsep(&amp;source, delm);
        printf(<span style="color: #ad7fa8;">"result:%s\n"</span>, result);
    }
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果
</p>
<pre class="example">
Source:To be or not to be | result:To
Source:be or not to be | result:be
Source:or not to be | result: or
Source:not to be | result: not
Source:to be | result: to
Source:be | result: be
</pre>

<p>
因为和strtok()的这个不同之处，strsep不需要区分第一次调用后后续的连续调用，可以用统一的操作来对字符串进行分割。
</p>
</div>
</div>
</div>
<div id="outline-container-orgheadline22" class="outline-2">
<h2 id="orgheadline22">字符串匹配(strstr)</h2>
<div class="outline-text-2" id="text-orgheadline22">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strstr</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">haystack</span>, <span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">needle</span>);
</pre>
</div>

<p>
strstr()返回字符串needle在字符串haystack中第一次出现的位置；如果没有匹配，则返回 <b>NULL</b> 。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"To be or not to be."</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">p</span> = <span style="color: #ad7fa8;">"be"</span>;

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, strstr(s, p));
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
be or not to be.
</pre>
</div>
</div>

<div id="outline-container-orgheadline23" class="outline-2">
<h2 id="orgheadline23">字符串副本创建(strdup, strndup, strdupa, strndupa)</h2>
<div class="outline-text-2" id="text-orgheadline23">
</div><div id="outline-container-orgheadline24" class="outline-3">
<h3 id="orgheadline24">strdup</h3>
<div class="outline-text-3" id="text-orgheadline24">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strdup</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>);
</pre>
</div>

<p>
strdup()调用malloc()分配一块内存并将字符串s的内容拷贝进去，产生s的副本。要注意的是，在最后应该调用free()来释放副本。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"abcde"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dup</span> = strdup(s);
    printf(<span style="color: #ad7fa8;">"%s\n"</span>, dup);
    free(dup);
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
abcde
</pre>
</div>
</div>
<div id="outline-container-orgheadline25" class="outline-3">
<h3 id="orgheadline25">strndup</h3>
<div class="outline-text-3" id="text-orgheadline25">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strndup</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">n</span>);
</pre>
</div>

<p>
strndup()和strdup()类似，但最多只拷贝s的前n个字节。如果s的长度大于n，还会在副本后添加终止符。
</p>

<p>
示例：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;stdio.h&gt;</span>
<span style="color: #729fcf;">#include</span> <span style="color: #ad7fa8;">&lt;string.h&gt;</span>

<span style="color: #8ae234;">int</span> <span style="color: #edd400;">main</span>(<span style="color: #8ae234;">int</span> <span style="color: #eeeeec;">argc</span>, <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">argv</span>[])
{
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span> = <span style="color: #ad7fa8;">"abcde"</span>;
    <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">dup</span> = strndup(s, 4);

    printf(<span style="color: #ad7fa8;">"%s\n"</span>, dup);

    free(dup);
    <span style="color: #729fcf;">return</span> 0;
}
</pre>
</div>

<p>
结果：
</p>
<pre class="example">
abcd
</pre>
</div>
</div>
<div id="outline-container-orgheadline26" class="outline-3">
<h3 id="orgheadline26">strdupa</h3>
<div class="outline-text-3" id="text-orgheadline26">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strdupa</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>);
</pre>
</div>

<p>
strdupa()和strdup()类似，但在分配内存时，它使用alloca()而不是malloc()。
</p>
</div>
</div>
<div id="outline-container-orgheadline27" class="outline-3">
<h3 id="orgheadline27">strndupa</h3>
<div class="outline-text-3" id="text-orgheadline27">
<p>
函数原型：
</p>
<div class="org-src-container">

<pre class="src src-C"><span style="color: #8ae234;">char</span> *<span style="color: #edd400;">strndupa</span>(<span style="color: #729fcf;">const</span> <span style="color: #8ae234;">char</span> *<span style="color: #eeeeec;">s</span>, <span style="color: #8ae234;">size_t</span> <span style="color: #eeeeec;">n</span>);
</pre>
</div>

<p>
strndupa()之于strdupa()就如strndup()之于strdup()，不再赘述。
</p>
</div>
</div>
</div>
